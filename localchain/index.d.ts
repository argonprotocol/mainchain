/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export const enum DataTLD {
  Analytics = 0,
  Automotive = 1,
  Bikes = 2,
  Business = 3,
  Cars = 4,
  Communication = 5,
  Entertainment = 6,
  Finance = 7,
  Flights = 8,
  Health = 9,
  Hotels = 10,
  Jobs = 11,
  News = 12,
  RealEstate = 13,
  Restaurants = 14,
  Shopping = 15,
  Sports = 16,
  Transportation = 17,
  Travel = 18,
  Weather = 19
}
export const enum AccountType {
  Tax = 0,
  Deposit = 1
}
export interface NotaryAccountOrigin {
  notaryId: number
  notebookNumber: number
  accountUid: number
}
export interface ClaimResult {
  claimed: bigint
  tax: bigint
}
export const enum BalanceChangeStatus {
  SubmittedToNotary = 0,
  SupersededInNotebook = 1,
  InNotebook = 2,
  Finalized = 3,
  WaitingForSendClaim = 4,
  Canceled = 5
}
export interface EscrowCloseOptions {
  escrowTaxAddress: string
  escrowClaimsSendToAddress?: string
  votesAddress: string
  /** What's the minimum amount of tax we should wait for before voting on blocks */
  minimumVoteAmount?: number
}
export interface DataDomain {
  domainName: string
  topLevelDomain: DataTLD
}
export interface LocalchainTransfer {
  address: string
  amount: bigint
  notaryId: number
  expirationBlock: number
  accountNonce: number
}
export interface AccountInfo {
  nonce: number
  consumers: number
  providers: number
  sufficients: number
  data: ArgonBalancesAccountData
}
export interface ArgonBalancesAccountData {
  free: bigint
  reserved: bigint
  frozen: bigint
  flags: bigint
}
export interface ZoneRecord {
  paymentAddress: string
  notaryId: number
  /** A mapping of versions to host addresses. */
  versions: Record<string, VersionHost>
}
export interface VersionHost {
  /** Datastore id is a 2-50 char string that uniquely identifies a data domain. */
  datastoreId: string
  /** The host address where the data domain can be accessed. */
  host: string
}
export interface NotaryDetails {
  id: number
  hosts: Array<string>
  publicKey: Uint8Array
}
export interface DataDomainRegistration {
  registeredToAddress: string
  registeredAtTick: number
}
export interface BestBlockForVote {
  blockHash: Uint8Array
  voteMinimum: bigint
}
export interface BlockVote {
  /** The creator of the seal */
  address: string
  /** The block hash being voted on. Must be in last 2 ticks. */
  blockHash: Array<number>
  /** A unique index per account for this notebook */
  index: number
  /** The voting power of this vote, determined from the amount of tax */
  power: bigint
  /** The data domain used to create this vote */
  dataDomainHash: Array<number>
  /** The data domain payment address used to create this vote */
  dataDomainAddress: string
  /** A signature of the vote by the account_id */
  signature: Array<number>
}
export interface FinalizedBlock {
  finalizedBlockNumber: number
  accountChangesMerkleRoot: Uint8Array
}
export interface NotebookProof {
  address: string
  accountType: AccountType
  notebookNumber: number
  balance: bigint
  /** H256 hash of the balance tip */
  balanceTip: Uint8Array
  changeNumber: number
  accountOrigin: NotaryAccountOrigin
  escrowHoldNoteJson?: string
  leafIndex: number
  numberOfLeaves: number
  proof: Array<Uint8Array>
}
export interface SignatureResult {
  signature: Uint8Array
  milligons: bigint
}
/**
 * Options to provide the password for a keystore. NOTE that this library cannot clear out memory in javascript.
 * Only a single option should be picked.
 */
export interface KeystorePasswordOption {
  /** Provides a password directly for the keystore. Converted to a SecretString inside Rust, but not cleared out in javascript or napi. */
  password?: Buffer
  /** Initiate a prompt from the cli to load the password. */
  interactiveCli?: boolean
  /** Load the password from a file. */
  passwordFile?: string
}
export interface LocalchainConfig {
  path: string
  mainchainUrl: string
  ntpPoolUrl?: string
}
export interface Constants {
  notarizationConstants: NotarizationConstants
  escrowConstants: EscrowConstants
  dataDomainConstants: DataDomainConstants
}
export interface NotarizationConstants {
  maxBalanceChanges: number
  maxDataDomains: number
  maxBlockVotes: number
}
export interface EscrowConstants {
  expirationTicks: number
  ticksToClaim: number
}
export interface DataDomainConstants {
  maxDatastoreVersions: number
  minDomainNameLength: number
  maxDomainNameLength: number
  leaseCost: bigint
}
export class LocalAccount {
  id: number
  address: string
  accountId32: string
  notaryId: number
  accountType: AccountType
  createdAt: number
  updatedAt: number
  origin?: NotaryAccountOrigin
}
export class AccountStore {
  constructor(localchain: Localchain)
  get(address: string, accountType: AccountType, notaryId: number): Promise<LocalAccount>
  getById(id: number): Promise<LocalAccount>
  insert(address: string, accountType: AccountType, notaryId: number): Promise<LocalAccount>
  list(): Promise<Array<LocalAccount>>
  taxAccounts(notaryId: number): Promise<Array<LocalAccount>>
}
export class BalanceChangeBuilder {
  accountType: AccountType
  address: string
  changeNumber: number
  static newAccount(address: string, accountType: AccountType): BalanceChangeBuilder
  isEmptySignature(): Promise<boolean>
  get balance(): Promise<bigint>
  get accountId32(): Promise<Uint8Array>
  send(amount: bigint, restrictToAddresses?: Array<string> | undefined | null): Promise<void>
  claim(amount: bigint): Promise<ClaimResult>
  claimEscrow(amount: bigint): Promise<ClaimResult>
  claimFromMainchain(transfer: LocalchainTransfer): Promise<void>
  sendToMainchain(amount: bigint): Promise<void>
  createEscrowHold(amount: bigint, dataDomain: DataDomain, dataDomainAddress: string): Promise<void>
  sendToVote(amount: bigint): Promise<void>
  /** Lease a data domain. DataDomain leases are converted in full to tax. */
  leaseDataDomain(): Promise<bigint>
  createPrivateServerEscrowHold(amount: bigint, paymentAddress: string): Promise<void>
}
export type BalanceChangeRow = BalanceChange
export class BalanceChange {
  id: number
  accountId: number
  changeNumber: number
  balance: string
  escrowHoldNoteJson?: string
  notaryId: number
  notesJson?: string
  proofJson?: string
  finalizedBlockNumber?: number
  status: BalanceChangeStatus
  notarizationId?: number
}
export class BalanceChangeStore {
  allForAccount(accountId: number): Promise<Array<BalanceChange>>
  getLatestForAccount(accountId: number): Promise<BalanceChange | null>
  cancel(id: number): Promise<void>
  getById(id: number): Promise<BalanceChange>
  findUnsettled(): Promise<Array<BalanceChange>>
}
export class BalanceSync {
  constructor(localchain: Localchain)
  sync(options?: EscrowCloseOptions | undefined | null, signer?: Signer | undefined | null): Promise<BalanceSyncResult>
  syncUnsettledBalances(): Promise<Array<BalanceChange>>
  syncBalanceChange(balanceChange: BalanceChange): Promise<BalanceChange>
  processPendingEscrows(options: EscrowCloseOptions, signer: Signer): Promise<Array<NotarizationBuilder>>
}
export class BalanceSyncResult {
  get balanceChanges(): Array<BalanceChange>
  get escrowNotarizations(): Array<NotarizationBuilder>
}
export type DataDomainRow = DataDomainLease
export class DataDomainLease {
  id: number
  name: string
  tld: number
  registeredToAddress: string
  notarizationId: number
  registeredAtTick: number
}
export class DataDomainStore {
  get list(): Promise<Array<DataDomainLease>>
  getHash(domainName: string, tld: DataTLD): Uint8Array
  isRegistered(domainName: string, tld: DataTLD): Promise<boolean>
  get(id: number): Promise<DataDomainLease>
}
export class MainchainClient {
  close(): Promise<void>
  static connect(host: string, timeoutMillis: number): Promise<MainchainClient>
  getBestBlockHash(): Promise<Uint8Array>
  getVoteBlockHash(currentTick: number): Promise<BestBlockForVote | null>
  getDataDomainRegistration(domainName: string, tld: DataTLD): Promise<DataDomainRegistration | null>
  getDataDomainZoneRecord(domainName: string, tld: DataTLD): Promise<ZoneRecord | null>
  getNotaryDetails(notaryId: number): Promise<NotaryDetails | null>
  getAccount(address: string): Promise<AccountInfo>
  getAccountNonce(address: string): Promise<number>
  waitForLocalchainTransfer(address: string, nonce: number): Promise<LocalchainTransfer | null>
  getAccountChangesRoot(notaryId: number, notebookNumber: number): Promise<Uint8Array>
  latestFinalizedNumber(): Promise<number>
  waitForNotebookFinalized(notaryId: number, notebookNumber: number): Promise<number>
}
export class NotarizationBuilder {
  set notaryId(notaryId: number)
  get notaryId(): Promise<number>
  get isFinalized(): Promise<boolean>
  get unclaimedTax(): Promise<bigint>
  get escrows(): Promise<Array<Escrow>>
  get accounts(): Promise<Array<LocalAccount>>
  get balanceChangeBuilders(): Promise<Array<BalanceChangeBuilder>>
  get unusedVoteFunds(): Promise<bigint>
  get unusedDomainFunds(): Promise<bigint>
  get unclaimedDeposits(): Promise<bigint>
  getBalanceChange(account: LocalAccount): Promise<BalanceChangeBuilder>
  addAccount(address: string, accountType: AccountType, notaryId: number): Promise<LocalAccount>
  loadAccount(account: LocalAccount): Promise<void>
  canAddEscrow(escrow: OpenEscrow, taxAddress: string): Promise<boolean>
  cancelEscrow(openEscrow: OpenEscrow): Promise<void>
  claimEscrow(openEscrow: OpenEscrow, taxAddress: string): Promise<void>
  addVote(vote: BlockVote): Promise<void>
  leaseDataDomain(useFundsFromAddress: string, taxAddress: string, dataDomain: DataDomain, registerToAddress: string): Promise<void>
  canAddBalanceChange(claimAddress: string, taxAddress: string): Promise<boolean>
  moveToSubAddress(fromAddress: string, toSubAddress: string, accountType: AccountType, amount: bigint, taxAddress: string): Promise<void>
  moveClaimsToAddress(address: string, accountType: AccountType, taxAddress: string): Promise<void>
  claimFromMainchain(transfer: LocalchainTransfer): Promise<BalanceChangeBuilder>
  claimReceivedBalance(balanceChangesJson: Buffer, claimAddress: string, taxAddress: string): Promise<void>
  /**
   * Exports balance changes (only) from this notarization builder with the intention that these will be sent to another
   * user (who will import them into their own localchain). The returned byffer is utf8 encoded json.
   */
  exportForSend(): Promise<Buffer>
  toJson(): Promise<string>
  notarizeAndWaitForNotebook(signer: Signer): Promise<NotarizationTracker>
  notarize(): Promise<NotarizationTracker>
  verify(): Promise<void>
  sign(signer: Signer): Promise<void>
}
export class NotarizationTracker {
  notebookNumber: number
  tick: number
  notaryId: number
  notarizationId: number
  notarizedBalanceChanges: number
  notarizedVotes: number
  /** Returns the balance changes that were submitted to the notary indexed by the stringified account id (napi doesn't allow numbers as keys) */
  get balanceChangesByAccount(): Promise<Record<string, BalanceChange>>
  waitForNotebook(): Promise<void>
  /** Asks the notary for proof the transaction was included in a notebook header. If this notebook has not been finalized yet, it will return an error. */
  getNotebookProof(): Promise<Array<NotebookProof>>
  /** Confirms the root added to the mainchain */
  waitForFinalized(mainchainClient: MainchainClient): Promise<FinalizedBlock>
}
export class NotaryClients {
  static new(mainchainClient: MainchainClient): NotaryClients
  useClient(client: NotaryClient): Promise<void>
  get(notaryId: number): Promise<NotaryClient>
}
export class NotaryClient {
  notaryId: number
  autoVerifyHeaderSignatures: boolean
  isConnected(): Promise<boolean>
  static connect(notaryId: number, publicKey: Uint8Array, host: string, autoVerifyHeaderSignatures: boolean): Promise<NotaryClient>
  getBalanceTip(address: string, accountType: AccountType): Promise<BalanceTipResult>
  get metadata(): Promise<NotebookMeta>
}
export class NotebookMeta {
  finalizedNotebookNumber: number
  finalizedTick: number
}
export class BalanceTipResult {
  balanceTip: Uint8Array
  notebookNumber: number
  tick: number
}
export class Escrow {
  initialBalanceChangeJson: string
  notaryId: number
  fromAddress: string
  toAddress: string
  dataDomainHash?: Array<number>
  expirationTick: number
  balanceChangeNumber: number
  notarizationId?: number
  isClient: boolean
  missedClaimWindow: boolean
  get holdAmount(): bigint
  get settledAmount(): bigint
  get settledSignature(): Uint8Array
  get id(): number
  isPastClaimPeriod(currentTick: number): boolean
}
export class OpenEscrow {
  get escrow(): Promise<Escrow>
  sign(settledAmount: bigint, signer: Signer): Promise<SignatureResult>
  exportForSend(): Promise<Buffer>
  recordUpdatedSettlement(milligons: bigint, signature: Uint8Array): Promise<void>
}
export class OpenEscrowsStore {
  get(id: number): Promise<OpenEscrow>
  open(escrow: Escrow): OpenEscrow
  getClaimable(): Promise<Array<OpenEscrow>>
  /** Import an escrow from a JSON string. Verifies with the notary that the escrow hold is valid. */
  importEscrow(escrowJson: Buffer): Promise<OpenEscrow>
  /** Create a new escrow as a client. You must first notarize an escrow hold note to the notary for the `client_address`. */
  openClientEscrow(accountId: number): Promise<OpenEscrow>
}
export class Signer {
  constructor(signer: (address: string, signatureMessage: Uint8Array) => Promise<Uint8Array>)
  attachKeystore(path: string, password: KeystorePasswordOption): Promise<void>
  sign(address: string, message: Uint8Array): Promise<Uint8Array>
  signWithKeystore(address: string, message: Uint8Array): Promise<Uint8Array>
}
export class Localchain {
  static load(config: LocalchainConfig): Promise<Localchain>
  close(): Promise<void>
  static getDefaultPath(): string
  get currentTick(): number
  get constants(): Constants
  get ticker(): TickerRef
  get mainchainClient(): MainchainClient
  get notaryClients(): NotaryClients
  get accounts(): AccountStore
  get balanceChanges(): BalanceChangeStore
  get dataDomains(): DataDomainStore
  get openEscrows(): OpenEscrowsStore
  get balanceSync(): BalanceSync
  beginChange(): NotarizationBuilder
}
export class TickerRef {
  get current(): number
  tickForTime(timestampMillis: number): number
  timeForTick(tick: number): bigint
  millisToNextTick(): bigint
}
