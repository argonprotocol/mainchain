/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export enum DataTLD {
  Analytics = 0,
  Automotive = 1,
  Bikes = 2,
  Business = 3,
  Cars = 4,
  Communication = 5,
  Entertainment = 6,
  Finance = 7,
  Flights = 8,
  Health = 9,
  Hotels = 10,
  Jobs = 11,
  News = 12,
  RealEstate = 13,
  Restaurants = 14,
  Shopping = 15,
  Sports = 16,
  Transportation = 17,
  Travel = 18,
  Weather = 19
}
export enum AccountType {
  Tax = 0,
  Deposit = 1
}
export interface NotaryAccountOrigin {
  notaryId: number
  notebookNumber: number
  accountUid: number
}
export interface ClaimResult {
  claimed: bigint
  tax: bigint
}
export enum BalanceChangeStatus {
  /** The balance change has been submitted, but is not in a known notebook yet. */
  SubmittedToNotary = 0,
  /** A balance change that doesn't get final proof because it is one of many in a single notebook. Aka, another balance change superseded it in the notebook. */
  SupersededInNotebook = 1,
  /** Proof has been obtained from a notebook */
  NotebookPublished = 2,
  /** The mainchain has finalized the notebook with the balance change */
  MainchainFinal = 3,
  /** A balance change has been sent to another user to claim. Keep checking until it is claimed. */
  WaitingForSendClaim = 4,
  /** A pending balance change that was canceled before being claimed by another user (escrow or send). */
  Canceled = 5
}
export interface EscrowCloseOptions {
  escrowTaxAddress: string
  escrowClaimsSendToAddress?: string
  votesAddress: string
  /** What's the minimum amount of tax we should wait for before voting on blocks */
  minimumVoteAmount?: number
}
export interface DataDomain {
  domainName: string
  topLevelDomain: DataTLD
}
export interface LocalchainTransfer {
  address: string
  amount: bigint
  notaryId: number
  expirationBlock: number
  accountNonce: number
}
export interface AccountInfo {
  nonce: number
  consumers: number
  providers: number
  sufficients: number
  data: ArgonBalancesAccountData
}
export interface ArgonBalancesAccountData {
  free: bigint
  reserved: bigint
  frozen: bigint
  flags: bigint
}
export interface ZoneRecord {
  paymentAddress: string
  notaryId: number
  /** A mapping of versions to host addresses. */
  versions: Record<string, VersionHost>
}
export interface VersionHost {
  /** Datastore id is a 2-50 char string that uniquely identifies a data domain. */
  datastoreId: string
  /** The host address where the data domain can be accessed. */
  host: string
}
export interface NotaryDetails {
  id: number
  hosts: Array<string>
  publicKey: Uint8Array
}
export interface DataDomainRegistration {
  registeredToAddress: string
  registeredAtTick: number
}
export interface BestBlockForVote {
  blockHash: Uint8Array
  voteMinimum: bigint
}
export interface BlockVote {
  /** The creator of the seal */
  address: string
  /** The block hash being voted on. Must be in last 2 ticks. */
  blockHash: Array<number>
  /** A unique index per account for this notebook */
  index: number
  /** The voting power of this vote, determined from the amount of tax */
  power: bigint
  /** The data domain used to create this vote */
  dataDomainHash: Array<number>
  /** The data domain payment address used to create this vote */
  dataDomainAddress: string
  /** A signature of the vote by the account_id */
  signature: Array<number>
}
export interface FinalizedBlock {
  finalizedBlockNumber: number
  accountChangesMerkleRoot: Uint8Array
}
export interface NotebookProof {
  address: string
  accountType: AccountType
  notebookNumber: number
  balance: bigint
  /** H256 hash of the balance tip */
  balanceTip: Uint8Array
  changeNumber: number
  accountOrigin: NotaryAccountOrigin
  escrowHoldNoteJson?: string
  leafIndex: number
  numberOfLeaves: number
  proof: Array<Uint8Array>
}
export interface SignatureResult {
  signature: Uint8Array
  milligons: bigint
}
/**
 * Options to provide the password for a keystore. NOTE that this library cannot clear out memory in javascript.
 * Only a single option should be picked.
 */
export interface KeystorePasswordOption {
  /** Provides a password directly for the keystore. Converted to a SecretString inside Rust, but not cleared out in javascript or napi. */
  password?: Buffer
  /** Initiate a prompt from the cli to load the password. */
  interactiveCli?: boolean
  /** Load the password from a file. */
  passwordFile?: string
}
export enum CryptoScheme {
  Ed25519 = 0,
  Sr25519 = 1,
  Ecdsa = 2
}
export function runCli(): Promise<void>
/** Max balance changes that can be in a single notarization */
export const NOTARIZATION_MAX_BALANCE_CHANGES: number
/** Max data domains that can be in a single notarization */
export const NOTARIZATION_MAX_DOMAINS: number
/** Max notarizations that can be in a single notarization */
export const NOTARIZATION_MAX_BLOCK_VOTES: number
/** Number of ticks past the notarization of an escrow hold that an escrow can be claimed (and no longer used) */
export const ESCROW_EXPIRATION_TICKS: number
/** Number of ticks past the expiration of an escrow that a recipient has to claim. After this point, sender can recoup the escrowed funds */
export const ESCROW_CLAWBACK_TICKS: number
/** Minimum milligons that can be settled in an escrow */
export const ESCROW_MINIMUM_SETTLEMENT: bigint
/** Max versions that can be in a datastore zone record */
export const DATASTORE_MAX_VERSIONS: number
/** Minimum data domain name length */
export const DATA_DOMAIN_MIN_NAME_LENGTH: number
/** Cost to lease a data domain for 1 year */
export const DATA_DOMAIN_LEASE_COST: bigint
/** The version of the Argon file format. */
export const VERSION: string
export enum ArgonFileType {
  Send = 0,
  Request = 1
}
export interface LocalchainConfig {
  dbPath: string
  mainchainUrl: string
  ntpPoolUrl?: string
}
export interface TickerConfig {
  tickDurationMillis: number
  genesisUtcTime: number
  ntpPoolUrl?: string
}
export class LocalAccount {
  id: number
  address: string
  accountId32: string
  notaryId: number
  accountType: AccountType
  createdAt: number
  updatedAt: number
  origin?: NotaryAccountOrigin
}
export class AccountStore {
  get(address: string, accountType: AccountType, notaryId: number): Promise<LocalAccount>
  getById(id: number): Promise<LocalAccount>
  hasAccount(address: string, accountType: AccountType, notaryId: number): Promise<boolean>
  /** Finds an account with no balance that is not waiting for a send claim */
  findFreeAccount(accountType: AccountType, notaryId: number): Promise<LocalAccount | null>
  insert(address: string, accountType: AccountType, notaryId: number): Promise<LocalAccount>
  list(): Promise<Array<LocalAccount>>
  taxAccounts(notaryId: number): Promise<Array<LocalAccount>>
}
export class BalanceChangeBuilder {
  accountType: AccountType
  address: string
  changeNumber: number
  syncStatus?: BalanceChangeStatus
  static newAccount(address: string, accountType: AccountType): BalanceChangeBuilder
  isEmptySignature(): Promise<boolean>
  get balance(): Promise<bigint>
  get accountId32(): Promise<Uint8Array>
  isPendingClaim(): Promise<boolean>
  send(amount: bigint, restrictToAddresses?: Array<string> | undefined | null): Promise<void>
  claim(amount: bigint): Promise<ClaimResult>
  claimEscrow(amount: bigint): Promise<ClaimResult>
  claimFromMainchain(transfer: LocalchainTransfer): Promise<void>
  sendToMainchain(amount: bigint): Promise<void>
  createEscrowHold(amount: bigint, dataDomain: string, dataDomainAddress: string): Promise<void>
  createPrivateServerEscrowHold(amount: bigint, paymentAddress: string): Promise<void>
  sendToVote(amount: bigint): Promise<void>
  /** Lease a data domain. DataDomain leases are converted in full to tax. */
  leaseDataDomain(): Promise<bigint>
}
export type BalanceChangeRow = BalanceChange
export class BalanceChange {
  id: number
  accountId: number
  changeNumber: number
  balance: string
  escrowHoldNoteJson?: string
  notaryId: number
  notesJson?: string
  proofJson?: string
  finalizedBlockNumber?: number
  status: BalanceChangeStatus
  notarizationId?: number
}
export class BalanceChangeStore {
  allForAccount(accountId: number): Promise<Array<BalanceChange>>
  getLatestForAccount(accountId: number): Promise<BalanceChange | null>
  cancel(id: number): Promise<void>
  getById(id: number): Promise<BalanceChange>
  findUnsettled(): Promise<Array<BalanceChange>>
}
export class BalanceSync {
  constructor(localchain: Localchain)
  sync(options?: EscrowCloseOptions | undefined | null, signer?: Signer | undefined | null): Promise<BalanceSyncResult>
  syncUnsettledBalances(): Promise<Array<BalanceChange>>
  syncBalanceChange(balanceChange: BalanceChange): Promise<BalanceChange>
  processPendingEscrows(options: EscrowCloseOptions, signer: Signer): Promise<Array<NotarizationBuilder>>
}
export class BalanceSyncResult {
  get balanceChanges(): Array<BalanceChange>
  get escrowNotarizations(): Array<NotarizationBuilder>
}
export type DataDomainRow = DataDomainLease
export class DataDomainLease {
  id: number
  name: string
  tld: string
  registeredToAddress: string
  notarizationId: number
  registeredAtTick: number
}
export class DataDomainStore {
  static tldFromString(tld: string): DataTLD
  get list(): Promise<Array<DataDomainLease>>
  hashDomain(domain: JsDataDomain): Uint8Array
  static getHash(domain: string): Uint8Array
  static parse(domain: string): DataDomain
  get(id: number): Promise<DataDomainLease>
}
export class MainchainClient {
  close(): Promise<void>
  static connect(host: string, timeoutMillis: number): Promise<MainchainClient>
  getBestBlockHash(): Promise<Uint8Array>
  getVoteBlockHash(currentTick: number): Promise<BestBlockForVote | null>
  getDataDomainRegistration(domainName: string, tld: DataTLD): Promise<DataDomainRegistration | null>
  getDataDomainZoneRecord(domainName: string, tld: DataTLD): Promise<ZoneRecord | null>
  getNotaryDetails(notaryId: number): Promise<NotaryDetails | null>
  getAccount(address: string): Promise<AccountInfo>
  getAccountNonce(address: string): Promise<number>
  waitForLocalchainTransfer(address: string, nonce: number): Promise<LocalchainTransfer | null>
  getAccountChangesRoot(notaryId: number, notebookNumber: number): Promise<Uint8Array>
  latestFinalizedNumber(): Promise<number>
  waitForNotebookFinalized(notaryId: number, notebookNumber: number): Promise<number>
}
export class NotarizationBuilder {
  set notaryId(notaryId: number)
  get notaryId(): Promise<number>
  get isFinalized(): Promise<boolean>
  get unclaimedTax(): Promise<bigint>
  get escrows(): Promise<Array<Escrow>>
  get accounts(): Promise<Array<LocalAccount>>
  get balanceChangeBuilders(): Promise<Array<BalanceChangeBuilder>>
  get unusedVoteFunds(): Promise<bigint>
  get unusedDomainFunds(): Promise<bigint>
  get unclaimedDeposits(): Promise<bigint>
  getBalanceChange(account: LocalAccount): Promise<BalanceChangeBuilder>
  addAccount(address: string, accountType: AccountType, notaryId: number): Promise<LocalAccount>
  loadAccount(account: LocalAccount): Promise<void>
  canAddEscrow(escrow: OpenEscrow, taxAddress: string): Promise<boolean>
  cancelEscrow(openEscrow: OpenEscrow): Promise<void>
  claimEscrow(openEscrow: OpenEscrow, taxAddress: string): Promise<void>
  addVote(vote: BlockVote): Promise<void>
  leaseDataDomain(useFundsFromAddress: string, taxAddress: string, dataDomain: string, registerToAddress: string): Promise<void>
  canAddBalanceChange(claimAddress: string, taxAddress: string): Promise<boolean>
  /** Calculates the transfer tax on the given amount */
  getTransferTaxAmount(amount: bigint): bigint
  /** Calculates the total needed to end up with the given balance */
  getTotalForAfterTaxBalance(finalBalance: bigint): bigint
  getEscrowTaxAmount(amount: bigint): bigint
  moveToSubAddress(fromAddress: string, toSubAddress: string, accountType: AccountType, amount: bigint, taxAddress: string): Promise<void>
  claimAndPayTax(milligons: bigint, address: string, taxAddress?: string | undefined | null): Promise<void>
  moveClaimsToAddress(address: string, accountType: AccountType, taxAddress: string): Promise<void>
  claimFromMainchain(transfer: LocalchainTransfer): Promise<BalanceChangeBuilder>
  loadFunding(milligons: bigint, fundWithAddress?: string | undefined | null, restrictToAddress?: string | undefined | null): Promise<void>
  isWholeBalance(address: string, milligons: bigint): Promise<boolean>
  fundAndNotarizeJumpAccount(milligons: bigint, signer: Signer, fromAddress?: string | undefined | null): Promise<LocalAccount>
  acceptRequestedBalanceChanges(argonFileJson: string, fundWithAddress?: string | undefined | null): Promise<void>
  claimReceivedBalance(argonFileJson: string, claimAddress: string, taxAddress: string): Promise<void>
  /**
   * Exports an argon file from this notarization builder with the intention that these will be sent to another
   * user (who will import into their own localchain).
   */
  exportAsFile(fileType: ArgonFileType): Promise<string>
  toJson(): Promise<string>
  notarizeAndWaitForNotebook(signer: Signer): Promise<NotarizationTracker>
  notarize(): Promise<NotarizationTracker>
  verify(): Promise<void>
  sign(signer: Signer): Promise<void>
}
export class NotarizationTracker {
  notebookNumber: number
  tick: number
  notaryId: number
  notarizationId: number
  notarizedBalanceChanges: number
  notarizedVotes: number
  /** Returns the balance changes that were submitted to the notary indexed by the stringified account id (napi doesn't allow numbers as keys) */
  get balanceChangesByAccountId(): Promise<Record<string, BalanceChange>>
  waitForNotebook(): Promise<void>
  /** Asks the notary for proof the transaction was included in a notebook header. If this notebook has not been finalized yet, it will return an error. */
  getNotebookProof(): Promise<Array<NotebookProof>>
  /** Confirms the root added to the mainchain */
  waitForFinalized(mainchainClient: MainchainClient): Promise<FinalizedBlock>
}
export class NotaryClients {
  static new(mainchainClient: MainchainClient): NotaryClients
  useClient(client: NotaryClient): Promise<void>
  get(notaryId: number): Promise<NotaryClient>
}
export class NotaryClient {
  notaryId: number
  autoVerifyHeaderSignatures: boolean
  isConnected(): Promise<boolean>
  static connect(notaryId: number, publicKey: Uint8Array, host: string, autoVerifyHeaderSignatures: boolean): Promise<NotaryClient>
  getBalanceTip(address: string, accountType: AccountType): Promise<BalanceTipResult>
  get metadata(): Promise<NotebookMeta>
}
export class NotebookMeta {
  finalizedNotebookNumber: number
  finalizedTick: number
}
export class BalanceTipResult {
  balanceTip: Uint8Array
  notebookNumber: number
  tick: number
}
export class Escrow {
  id: string
  initialBalanceChangeJson: string
  notaryId: number
  fromAddress: string
  toAddress: string
  dataDomainHash?: Array<number>
  expirationTick: number
  balanceChangeNumber: number
  notarizationId?: number
  isClient: boolean
  missedClaimWindow: boolean
  get holdAmount(): bigint
  get settledAmount(): bigint
  get settledSignature(): Uint8Array
  isPastClaimPeriod(currentTick: number): boolean
}
export class OpenEscrow {
  get escrow(): Promise<Escrow>
  sign(settledAmount: bigint, signer: Signer): Promise<SignatureResult>
  exportForSend(): Promise<string>
  recordUpdatedSettlement(milligons: bigint, signature: Uint8Array): Promise<void>
}
export class OpenEscrowsStore {
  get(id: string): Promise<OpenEscrow>
  open(escrow: Escrow): OpenEscrow
  getClaimable(): Promise<Array<OpenEscrow>>
  /** Import an escrow from a JSON string. Verifies with the notary that the escrow hold is valid. */
  importEscrow(escrowJson: string): Promise<OpenEscrow>
  /** Create a new escrow as a client. You must first notarize an escrow hold note to the notary for the `client_address`. */
  openClientEscrow(accountId: number): Promise<OpenEscrow>
}
export class Signer {
  constructor(signer?: (address: string, signatureMessage: Uint8Array) => Promise<Uint8Array>)
  createAccountId(scheme: CryptoScheme): string
  attachKeystore(path: string, password: KeystorePasswordOption): Promise<void>
  canSign(address: string): boolean
  sign(address: string, message: Uint8Array): Promise<Uint8Array>
  signWithKeystore(address: string, message: Uint8Array): Promise<Uint8Array>
}
export class Localchain {
  path: string
  static load(config: LocalchainConfig): Promise<Localchain>
  static loadWithoutMainchain(dbPath: string, tickerConfig: TickerConfig): Promise<Localchain>
  attachMainchain(mainchainClient: MainchainClient): Promise<void>
  close(): Promise<void>
  static getDefaultPath(): string
  get currentTick(): number
  get ticker(): TickerRef
  get mainchainClient(): Promise<MainchainClient | null>
  get notaryClients(): NotaryClients
  get accounts(): AccountStore
  get balanceChanges(): BalanceChangeStore
  get dataDomains(): DataDomainStore
  get openEscrows(): OpenEscrowsStore
  get balanceSync(): BalanceSync
  beginChange(): NotarizationBuilder
}
export class TickerRef {
  get current(): number
  tickForTime(timestampMillis: number): number
  timeForTick(tick: number): bigint
  millisToNextTick(): bigint
}
